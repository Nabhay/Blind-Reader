import cv2
import time
import os
from PIL import Image
import google.generativeai as genai
import pyttsx3
import argparse

from Secret_Parser import get_Secrets  # Ensure this module is available and correctly configured

def capture_and_save_image(base_dir='result', camera_id=0, width=1920, height=1080):
    """
    Capture an image from the specified camera and save it with a timestamp.
    
    Args:
        base_dir (str): Directory where images will be saved.
        camera_id (int): ID of the camera to use.
        width (int): Width of the captured image.
        height (int): Height of the captured image.
    
    Returns:
        str: Timestamp representing the saved image's directory.
    """
    # Initialize camera
    cap = cv2.VideoCapture(camera_id)

    # Set resolution
    cap.set(cv2.CAP_PROP_FRAME_WIDTH, width)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, height)

    # Capture image
    ret, photo = cap.read()
    if not ret:
        cap.release()
        raise RuntimeError("Failed to capture image")

    # Release camera
    cap.release()

    # Generate timestamp and create the corresponding directory
    timestamp = time.strftime('%Y-%m-%d_%H-%M-%S')
    print(f"Image captured at {timestamp}")
    save_dir = os.path.join(base_dir, timestamp)
    if not os.path.exists(save_dir):
        os.makedirs(save_dir)
        print(f"Created directory: {save_dir}")

    # Create the full save path
    filename = os.path.join(save_dir, f"{timestamp}.png")

    # Save the image
    cv2.imwrite(filename, photo)
    print(f"Image saved to {filename}")

    # Return the timestamp (directory name)
    return timestamp

def describe_surroundings(name, secrets):
    """
    Use Google Gemini to describe the surroundings based on the captured image.
    
    Args:
        name (str): Timestamp representing the image's directory.
        secrets (dict): Dictionary containing API keys and other secrets.
    
    Returns:
        str: Description generated by Gemini.
    """
    # Define the paths
    image_path = os.path.join('result', name, f"{name}.png")
    modified_file_path = os.path.join('result', name, 'description.txt')

    # Load the image
    image = Image.open(image_path).convert('RGB')

    # Configure Gemini
    genai.configure(api_key=secrets["Google_Gemini_Api"])
    model = genai.GenerativeModel(model_name="gemini-1.5-pro")

    # Generate description
    print("Generating description with Gemini...")
    response = model.generate_content(
        ['Describe the surroundings in the image with vivid descriptions and adjectives. Do remember that you have to make it brief aswell as the environment will keep changing. Hence the max should be around 150-175 words', image],
        generation_config=genai.types.GenerationConfig(temperature=0.7)
    )

    description = response.text.strip()
    print(f"Description: {description}")

    # Save the description to a file
    with open(modified_file_path, 'w') as file:
        file.write(description)
    print(f"Description saved to {modified_file_path}")

    return description

def tts(text):
    """
    Convert text to speech using pyttsx3.
    
    Args:
        text (str): Text to be spoken.
    """
    engine = pyttsx3.init()
    engine.say(text)
    engine.runAndWait()

def main():
    """
    Main function to capture an image, describe its surroundings using Gemini, and optionally read it aloud.
    """
    # Parse command-line arguments
    parser = argparse.ArgumentParser(description="Capture image and describe surroundings.")
    parser.add_argument('-b', '--braille', action='store_true', help="Enable Braille processing mode")
    args = parser.parse_args()

    # Load secrets
    secrets = get_Secrets()  # Ensure this function returns a dictionary with necessary keys

    # Capture image
    try:
        name = capture_and_save_image(camera_id=0)  # Adjust camera_id if necessary
    except RuntimeError as e:
        print(e)
        return

    # Describe surroundings
    try:
        description = describe_surroundings(name, secrets)
    except Exception as e:
        print(f"Failed to generate description: {e}")
        return

    # Always convert description to speech
    try:
        tts(description)
        print("Description has been read aloud.")
    except Exception as e:
        print(f"Failed to convert text to speech: {e}")

    # Handle Braille processing if enabled
    if args.braille:
        try:
            import Braille  # Ensure this module is available
            braille_file_path = os.path.join('result', name, 'description.txt')
            Braille.process_braille_file(braille_file_path)
            print("Braille processing completed.")
        except ImportError:
            print("Braille module not found. Please ensure it's installed and accessible.")
        except Exception as e:
            print(f"Failed to process Braille: {e}")

if __name__ == '__main__':
    main()